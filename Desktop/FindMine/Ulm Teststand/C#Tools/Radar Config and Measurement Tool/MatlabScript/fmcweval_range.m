function [tlist] = fmcweval_range(rad, ev, tlist, ts1, Mszf, Sszf)
% Sub-routine of fmcweval for range measuremente of detected
% targets.
% Input parameters:
% rad: radar paramter set
% ev: evaluation parameter set
% tlist: target list generated by detection process
% ts1: vector with sample times
% Mszf: matrix with sampled time domain data
% Sszf: matrix with spectral range data
%
% Output parameters:
% tlist: range results in the target list
%
% 15000058 VP E-Band
% W. Mayer, FEW, 4.11.2009
% 
% syntax: [tlist] = fmcweval_range(rad, ev, tlist, ts1, Mszf);
%
% Last Modification
% W. Mayer, TTD, 5.2.2016 calculate noise under target

dim_tlist = size(tlist.i);

for ml = 1:dim_tlist(2),                % for all detected targets
    for rl = 1:rad.rpc,                 % for all ramps per measureement cycle
        dr = ev.rbin;
        if tlist.i(rl,ml) > 1 && tlist.i(rl,ml) <  ev.nfft/2
            switch ev.rmp
                case 1  % range measurement procedure with 'dft'
                il = 0;
                fm = (tlist.i(rl,ml)-1) * ev.fbin; 
                fl = fm - ev.fbin;
                fh = fm + ev.fbin;
                % comment: in case of same normalization in FFT and DFT the
                % following three dft-caluclations could be cancelled to
                % save processing time.
                usf = ev.rmpars(3);
                am = abs(dft_us(Mszf(rl,:),ts1,fm,usf));
                al = abs(dft_us(Mszf(rl,:),ts1,fl,usf));
                ah = abs(dft_us(Mszf(rl,:),ts1,fh,usf));
                %disp(['start: fm=' num2str(fm) ' al=' num2str(al) ' ah=' num2str(ah) ' am=' num2str(am)]);
                
                rnew = fm*c0/(2*rad.S);
                while (dr > ev.rmpars(1) && il <= ev.rmpars(2))
                    if al > ah
                        fh = fm;                        % shift center point fm to right side limit
                        fm = fm - (fm-fl)/2;            % calculate new center point frequency
                        ah = am;                        % shift amplitude from center point to to right side limit
                        ak = dft_us(Mszf(rl,:), ts1, fm, usf);  % calculate new center point complex amplitude
                        am = abs(ak);                   % take absolute value for new center point amplitude
                        %disp(['al > ah fm=' num2str(fm) ' al=' num2str(al) ' ah=' num2str(ah) ' am=' num2str(am)]);
                    elseif al <= ah
                        fl = fm;                        % shift center point fm to left side limit
                        fm = fm + (fh-fm)/2;            % calculate new center point frequency
                        al = am;                        % shift amplitude from center point to to left side limit       
                        ak = dft_us(Mszf(rl,:), ts1, fm, usf);  % calculate new center point complex amplitude
                        am = abs(ak);                   % take absolute value for new center point amplitude
                        %disp(['al < ah fm=' num2str(fm) ' al=' num2str(al) ' ah=' num2str(ah) ' am=' num2str(am)]);
                    end;
                    rnew = [rnew fm*c0/(2*rad.S)];
                    dr = abs(rnew(length(rnew))-rnew(length(rnew)-1));
                    %rtest = [rtest rnew];
                    il = il+1;
                end;
                    % store range measurement result
                    tlist.a(rl,ml) = ak;                    % store complex peak value in target list
                    tlist.r(rl,ml) = rnew(length(rnew));                  % store exact range value in target list
                    % calculate noise under target
                    nistart = tlist.i-floor(ev.noisewindow/2);
                    nistop = tlist.i+floor(ev.noisewindow/2);
                    if nistart < 1 
                        nistart = 1;
                    end;
                    if nistop > ev.nfft/2;
                        nistop = ev.nfft/2;
                    end;
                    tlist.n(rl,ml) = mean(abs(Sszf(nistart:nistop,rl)));
                
                %end of case 1
                
                case 2 % range measurement with parable fit based on dB-values
                % calculate dB-values
                %SszfdB = 20*log10(abs(Sszf));
                SszfdB = abs(Sszf);
                
                % 3-point-fit (default setting)
                if (ev.rmpars(1) >= 0 && ev.rmpars(1) <= 3)
                    xv = [tlist.i(rl,ml)-1 tlist.i(rl,ml) tlist.i(rl,ml)+1];
                    yv = [SszfdB(xv(1),rl) SszfdB(xv(2),rl) SszfdB(xv(3),rl)];
                    xv = xv';
                    
                    % multi-point-fit with number of points chosen by the user
                elseif floor(ev.rmpars(1)) > 3
                    nfits = floor(ev.rmpars(1));
                    xv = tlist.i(rl,ml)-floor(nfits/2) : tlist.i(rl,ml)+floor(nfits/2);
                    xv(find(xv<1))=1;
                    yv = SszfdB(xv,rl);
                
                    % multi point fit with number of points determined by a dBc-limit
                elseif floor(ev.rmpars(1)) < 0
                    countleft = 1;
                    while SszfdB(tlist.i(rl,ml))-SszfdB(tlist.i(rl,ml)-countleft) < abs(ev.rmpars(1))
                        countleft = countleft + 1;
                        if tlist.i(rl,ml)-countleft <= 1 
                            break;
                        end;
                    end;
                    countright = 1;
                    while SszfdB(tlist.i(rl,ml))-SszfdB(tlist.i(rl,ml)+countright,rl) < abs(ev.rmpars(1))
                        countright = countright + 1;
                        if tlist.i(rl,ml)+countright >= length(SszfdB(:,rl))
                            break;
                        end;
                    end;
                    xv = tlist.i(rl,ml)-countleft : tlist.i(rl,ml)+countright;
                    yv = SszfdB(xv,rl);
                end;
                
                % perform parable fit
                xv=xv';
                warning off;
                a = polyfit(xv,yv,2);
                x0 = sum(roots(a))/2;
                warning on;
                rnew = (x0-1)*ev.rbin;
                ak = dft_us(Mszf(rl,:), ts1, x0*ev.fbin, 1);
                
                % store range measurement result
                tlist.a(rl,ml) = ak;                    % store complex peak value in target list
                tlist.r(rl,ml) = rnew;                  % store exact range value in target list
                % end of case 2  
            end; % switch range detection method 
        end; % end of if expression for target list length       
   end; % end of rl for-loop
end; % end of ml for-loop